# @pbrgld/Loggify

> ‚ö†Ô∏è **Project Status: Early Development** ‚ö†Ô∏è
>
> üöß **Warning:** Loggify is currently in an **early development stage**.  
> The version on the `main` branch is considered **unstable** and may change significantly.
>
> üß™ Expect breaking changes as features are added and the API evolves.
>
> üôå Your feedback, bug reports, and contributions are highly appreciated!  
> Help shape Loggify into a reliable and performant logging tool.
>
> ---

Loggify is a fast, zero-dependency logging library built for modern JavaScript and TypeScript runtimes ‚Äì especially fun with Bun.js!

Designed for developers who want more expressive and structured logs without sacrificing performance, loggify brings a fresh logging experience using styled output, emoji-enhanced messages, and flushable contextual logs that keep related information together.

## üöÄ Features

- ‚ö° **Zero dependencies** ‚Äì lightweight and fast by design
- üßµ **Context-aware logging** ‚Äì group related logs and flush them together
- üñ®Ô∏è **Uses stdout instead of console.log** ‚Äì for faster, cleaner output
- üé® **Styled text output** ‚Äì control colors, formatting, and visibility
- üïµÔ∏è **Caller info support** ‚Äì trace logs back to where they were triggered
- üïí **Customizable timestamps** ‚Äì add or remove as needed
- üòé **Emoji-based or text-based tags** ‚Äì switch as you like
- üîß **Built to play nicely with Bun.js** ‚Äì but works with Node.js too!

## ‚öôÔ∏è Installation

You can install **Loggify** using either `bun` or `npm`:

### Using bun

```bash
bun add @pbrgld/loggify
```

### Using `npm` for node.js

```bash
npm install @pbrgld/loggify
```

## üß© Use in Your Code

**Loggify** works seamlessly with both **TypeScript** and **JavaScript** projects.

### TypeScript Example

```ts
import Loggify from "@pbrgld/loggify";

const loggify: Loggify = new Loggify();

loggify.console("Hello world");
```

### Simple console log

In the most simplest way, use the console method and provide a string as message to be sent to the console. As second parameter you can define a log type e.g. "okay", "success", "warn", "error" or the identifier for an emoji:

```ts
loggify.console("Hello world", "rocket");
```

![Output: simple console log](documentation/caseSimpleLog.png)

> üß† **Note:** Constructor Defaults & Auto-Configuration
>
> If the constructor is called without any arguments, a comprehensive default initialization is applied.
> This ensures that Loggify is fully functional out of the box, using sensible defaults for context management, output styling, and performance-optimized logging behavior.
> The defaults settings are:
>
> - Show log type as emoji
> - Log timestamp as time only
> - Show app's current memory consumption: Heap used, Heap total and total memory allocation in memors (rss)
> - Caller information (shows file as well as line and eventually function from where this log informtaion has been triggered from)
> - Followed by the message provided

### Constructor Parameters

You can configure Loggify by passing an options object to the constructor.
This allows you to customize the logger‚Äôs behavior to fit your project‚Äôs structure, output preferences, and runtime environment.

The available parameters are well-typed and fully documented through TypeScript definitions ‚Äì so you can rely on auto-completion and inline hints in modern editors to explore all configuration options.

Simply pass the options you need ‚Äì and omit the rest. Loggify applies sensible defaults for any parameters you leave out.

```ts
const loggify: Loggify = new Loggify({
  logCallerInformation: false,
  logMemoryUsage: false,
  logTimestamp: {
    enabled: true,
    mode: "dateTime",
  },
});
```

![Output: removed caller information and memory usage via constructor](documentation/constructorNoMeMCaller.png)

> üëÜ **Hint:** This is an example, how to set the parameters in the constructor to remove caller information and memory usage and log the timestamp in date-time mode.

### Text coloring and styling and using emojis

**Loggify** supports inline styling and emoji enhancements directly within your message strings, using a simple and expressive tag syntax inspired by HTML.

To apply styling or emojis, use square brackets followed by a type (ansi or emoji) and a colon-separated value.

#### Syntax

- [ansi:<style|color>] ‚Äî Apply text styles or colors

  e.g., red, yellow, green, italic, underline, inverse

- [emoji:<name>] ‚Äî Inject emoji symbols by keyword

  e.g., check, rocket, warning, bug

- [ansi:reset] ‚Äî Resets the style to default (required to stop inherited formatting)

#### Example

```ts
loggify.console(
  "Hello [ansi:underline]world[ansi:reset]! This will be [ansi:red]red[ansi:reset] and [ansi:blue][ansi:inverse]blue[ansi:reset] text and showing an emoji [emoji:success]  ",
  "rocket"
);
```

![Output: Color, style and emoji logging](documentation/caseColorStyleEmoji.png)

This feature gives you powerful control over the visual appearance of your logs ‚Äî without needing external dependencies or manual ANSI codes.

### Object Logging Made Clear and Informative

**Loggify** supports clean and structured logging of complex objects right out of the box.
Just pass any object to the logger, and **Loggify** will take care of the rest:

- ‚úÖ Outputs in a readable and color-coded format, with type-specific highlighting
- üß† Automatically determines the buffer size and character length of the object
- üß© Supports deeply nested structures and mixed data types
- üéØ Designed to preserve clarity, even in large or dynamic logs

This makes it easier to inspect the state of your application without losing track of key information ‚Äì especially in asynchronous or data-heavy environments.

```ts
loggify.console("Hello world", "rocket", {}, object);
```

![Output: object logging](documentation/caseObject.png)

### Log example for time measuring

**Loggify** supports built-in performance metrics logging by passing a metrics object through the logger options.

You can provide:

- A start and end timestamp (e.g. from performance.now())
- Or a direct duration in milliseconds
- (Optionally) set the log type to 'metrics' to emphasize performance-related output

When metrics are provided, **Loggify** will automatically calculate and append the duration to the log message.
Even better: durations are automatically converted into human-readable formats like seconds, minutes, or hours ‚Äî depending on the threshold ‚Äî so they‚Äôre much easier to interpret at a glance.

```ts
// Start performance timer
const performanceTimerStart: number = performance.now();
// < Your code goes here
// End performance timer
const performanceTimerEnd: number = performance.now();
loggify.console("Hello world", "metrics", {
  metrics: {
    start: performanceTimerStart,
    end: performanceTimerEnd,
  },
});
```

This makes it simple to track the performance of asynchronous operations and benchmark critical sections of your application ‚Äî without manual formatting or external tools.

![Output: metrics](documentation/caseMetrics.png)

> üß† **Advanced notice:** You can either pass the performance counter _start_ and end _metrics_ via the metrics object or alternatively you can pass milliseconds to the _duration_ parameter if you only have a result value.

### Context logging example

**Loggify** supports context-based logging, a powerful mechanism that lets you group related log messages under a shared execution context ‚Äî and output them all at once, in a clean, structured block.

This is especially helpful for asynchronous workflows or parallel processes, where traditional logging often becomes fragmented and hard to follow.

#### üîß How It Works

1. Generate a unique contextId using the built-in **Loggify.generateContextId()** method.
2. Pass this contextId to each log call associated with the same logical process.
3. Instead of immediately printing, Loggify will collect all related logs in-memory using a performant internal HashMap.
4. Once the operation completes, call **Loggify.flush(contextId)** to output the entire log block to the console.

#### üöÄ Key Benefits

- üß† Consolidated Logs: All logs related to a context are grouped and printed together ‚Äî no more scattered entries across hundreds of lines.
- üïí Optional Duration Tracking: Loggify measures and includes the total execution time for each context block.
- ‚ö° High Performance: Logging operations are non-blocking and memory-efficient.
- ‚ôæÔ∏è Fully Concurrent: You can manage an unlimited number of parallel logging contexts without interference.

üìå Example

```ts
// Define a unique contextID
const uniqueContextId: string = loggify.generateContextId();

// Initialize the context by passing contextID and optionally title as well as performance start
loggify.console("Demo function start", "init", {
  context: {
    id: uniqueContextId,
    title: "Demo function for documentation",
    start: performance.now(),
  },
});

// Append context based logging by adding the contextID in each log statement
loggify.console("Some logging inside the demo function", undefined, {
  context: { id: uniqueContextId },
});

// Finish by either error or success, adding contextID of course as well as performance end timer if you wish
loggify.console("Demo function end", "finished", {
  context: { id: uniqueContextId, end: performance.now() },
});

// Finally use the flush method and provide the contextID to send everything to console
loggify.flush(uniqueContextId);
```

![Output: context based logging](documentation/caseContext.png)

## üß≠ Project Philosophy & Community Focus

This is the **first package** I‚Äôm sharing with the community ‚Äì and it‚Äôs something I deeply care about.
With **Loggify**, my goal is to create a logging tool that helps developers stay focused, informed, and productive ‚Äì especially when working on complex projects with asynchronous processes and nested dependencies.

Logging is not just a technical feature ‚Äì it‚Äôs a **developer‚Äôs compass** in growing codebases.
When things get messy, good logs can mean the difference between clarity and chaos.

That‚Äôs why **Loggify** focuses on:

- ‚úÖ **Simplicity** ‚Äì clear API, no unnecessary complexity
- üöÄ **Performance** ‚Äì using stdout, no dependencies
- üí° **Developer Experience** ‚Äì styled, structured, and readable logs
- üîÅ **General-purpose use cases** ‚Äì helpful in any project context
- ü§ù **Community-driven development** ‚Äì your input matters!

If **Loggify** helps you solve a problem, I‚Äôd love to hear about it ‚Äì and I‚Äôm happy to support others in turning their ideas into reality. Let‚Äôs build something useful together.

### üó∫Ô∏è Roadmap ‚Äì What‚Äôs Next for Loggify

Loggify is just getting started, and there are exciting features on the horizon!  
The following improvements are planned to make Loggify even more powerful and flexible for all kinds of environments and use cases.

#### ‚úÖ Planned Features

1. **üåê Browser Support**  
   Currently, Loggify is optimized for **Node.js** and **Bun.js** environments.  
   Future versions will bring compatibility with modern browsers and frontend workflows.

2. **üé® Custom Style Templates (Tag-Based)**  
   Instead of manually setting styles like `color` or `bold`, you‚Äôll be able to use **semantic tags** like `[style:file]`, `[style:warning]`, etc.  
   These tags will map to custom-defined style presets ‚Äì making your logging both cleaner and more expressive.

## üìù License

This project is licensed under the MIT License ‚Äì see the [LICENSE](./LICENSE) file for details.  
¬© 2025 Paul Bergold
